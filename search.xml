<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2016 Bronze February p1</title>
    <url>/y65ng/2020/11/12/2016%20Bronze%20February%20p1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>已知三个容量分别为 X，Y 和 M 的桶，且 X &lt; Y &lt; M。有两种方式可以往桶 M 中倒牛奶：</p>
<ol>
<li>装满桶 X 并全部倒入桶 M</li>
<li>装满桶 Y 并全部倒入桶 M</li>
</ol>
<p>求不溢出的情况下，桶 M 最多能装多少牛奶。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先全部用桶 Y 来倒，再逐渐把 Y 换成 X，并记录所有情况中倒最大值</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>M 的范围为 [1, 1000]，而 X 和 Y 都小于 M，直接枚举最坏情况下，时间复杂度大约为 O(10^3)，因此不会超时</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>USACO</category>
        <category>Bronze</category>
      </categories>
  </entry>
  <entry>
    <title>2016 Bronze January p3</title>
    <url>/y65ng/2020/11/12/2016%20Bronze%20January%20p3/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个升序序列中有一个不符合升序条件的元素，每次交换两个元素，求使序列恢复升序最小的步骤数</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先找到不符合要求元素的位置和它应该在的位置，然后从该元素位置向原位置遍历，途中若某元素与上一个元素不相同，则步骤数加一。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>找到不符合要求元素位置和原位置的复杂度均为 O(n)，遍历的复杂度也为 O(n)，因此总复杂度为 O(n)。元素数量最大为 100，因此不会超时。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>USACO</category>
        <category>Bronze</category>
      </categories>
  </entry>
  <entry>
    <title>2016 Bronze Open Contest p1</title>
    <url>/y65ng/2020/11/12/2016%20Bronze%20Open%20Contest%20p1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个数组中有 N 个元素，找出最大数量的元素，使这些元素最大值和最小值的差不超过 K</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先将数组排序，用一个循环遍历数组，每次循环中有一个小循环找到当前元素和与当前元素相差小于 K 的元素的最远距离，并记录距离的最大值</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>排序的复杂度为 O(n logn)，嵌套循环的复杂度为 O(n^2)。N 的范围是 [1, 1000]，K 的范围是 [0, 10000]，因此最多会执行大约 10^7 次操作，不会超时</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>USACO</category>
        <category>Bronze</category>
      </categories>
  </entry>
  <entry>
    <title>2016 Silver December p1</title>
    <url>/y65ng/2020/11/12/2016%20Silver%20December%20p1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出一个长度为 N 的数列和 M 个范围（1 ≤ N ≤ 100000, 1 ≤ M ≤ 100000），分别求出数列中有多少个数在范围内。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先将数列排序，用二分法分别找出数列中对应数字的 index，再用上界的 index 减下界的 index</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>排序的复杂度为 N logN，对 M 个范围分别用二分法的复杂度为 M logN，总复杂度最大为 10^5 log(10^5)，不会超时</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>USACO</category>
        <category>Silver</category>
      </categories>
  </entry>
  <entry>
    <title>2016 Silver December p3</title>
    <url>/y65ng/2020/11/12/2016%20Silver%20December%20p3/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一共有 $n$ 头奶牛，每头奶牛站在不同的位置 $(x, y)$，并拥有一个广播半径为 $p$ 的对讲机（每只奶牛的 $p$ 不一定相同）。求从某只奶牛开始能联系到最多的奶牛数是多少（单向）</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将奶牛坐标装进一个数组中，将每只奶牛的 $p$ 装进另一个 $index$ 都一一对应的数组。遍历装坐标的数组，利用递归计算当前奶牛能联系到的所有奶牛数，并得出最大值</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>遍历长度为 $n$ 数组的复杂度为 $O(n)$，其中每个元素递归最坏的复杂度也为 $O(n)$，总复杂度为 $O(n^2)$。$n$ 最大为 200，不会超时</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-python">def distance(p1, p2):
    return ((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2) ** 0.5

def neighbors(pos):
    global poses, powers

    result = set()
    for i in range(len(poses)):
        if i == pos: continue
        if distance(poses[pos], poses[i]) &lt;= powers[pos]: result.add(i)
    return result

def process(pos):
    global poses, visited

    visited.add(pos)
    neighbor_pos = neighbors(pos)
    #print(neighbor_pos)
    if len(neighbor_pos) == 0: return
    for neighbor in neighbor_pos:
        if neighbor not in visited: process(neighbor)

lines = open(&#39;moocast.in&#39;).read().strip().split(&#39;\n&#39;)
n = int(lines[0])
poses = []
powers = []

for i in range(1, n + 1):
    line = list(map(int, lines[i].split(&#39; &#39;)))
    pos = (line[0], line[1])
    power = line[2]
    poses.append(pos)
    powers.append(power)

max_size = 0
for i in range(len(poses)):
    visited = set()
    process(i)
    max_size = max(len(visited), max_size)

print(max_size)
file = open(&#39;moocast.out&#39;, &#39;w&#39;)
file.write(str(max_size))
file.close()
</code></pre>
]]></content>
      <categories>
        <category>CS</category>
        <category>USACO</category>
        <category>Silver</category>
      </categories>
  </entry>
  <entry>
    <title>2016 Silver January p1</title>
    <url>/y65ng/2020/11/12/2016%20Silver%20January%20p1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出 N 个草垛的坐标以及能用的奶牛数量 K，要求得出只用 K 只奶牛能炸完所有草垛的奶牛最小爆炸半径。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于爆炸半径大于等于最小爆炸半径就一定能炸完所有草垛，小于就一定炸不完，所以可以用二分查找法来找到最小半径。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>在 n 个元素中用二分查找法找到某个元素的复杂度为O(logn)，每次选择一个元素后检查是否合法的复杂度为 O(n)，因此整个二分法的复杂度为O(n logn)。K 的范围是 1 - 10，草垛数量的范围是1 - 50000，时间复杂度最大约为 10 log50000，因此不会超时</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>USACO</category>
        <category>Silver</category>
      </categories>
  </entry>
  <entry>
    <title>2017 Silver January p2</title>
    <url>/y65ng/2020/11/12/2017%20Silver%20January%20p2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Famer John 和 Bessie 猜拳。在 $n$ 次猜拳中 ($1 ≤ n ≤ 100000$)，Bessie 只会变一次手势，给出 Farmer John 每次出的手势，求 Bessie 能赢的最大次数</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将 FJ 每次出的手势装进一个 prefix 数组中，数组的每个元素是当前 FJ 出过三个手势分别的次数。遍历装 FJ 手势的数组，计算每次 Bessie 赢的次数，并求出最大值</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>创建一个 prefix 数组的复杂度为 $O(n)$，遍历数组的复杂度为 $O(n)$，利用 prefix 计算赢的次数的复杂度为 $O(1)$，总复杂度为 $O(n)$，$n$ 最大为 100000，不会超时</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-python">def win(a, b, i):
    global gestures, prefix

    count = 0
    count += prefix[i][a] + prefix[-1][b] - prefix[i][b]
    return count

lines = open(&#39;hps.in&#39;).read().strip().split(&#39;\n&#39;)
n = int(lines[0])
gestures = lines[1:]
prefix = []
for i in range(n):
    if i == 0:
        if gestures[i] == &#39;H&#39;: prefix.append((1,0,0))
        elif gestures[i] == &#39;P&#39;: prefix.append((0, 1, 0))
        else: prefix.append((0,0,1))
    else:
        h = prefix[i - 1][0]
        p = prefix[i - 1][1]
        s = prefix[i - 1][2]
        if gestures[i] == &#39;H&#39;: prefix.append((h + 1, p, s))
        elif gestures[i] == &#39;P&#39;: prefix.append((h, p + 1, s))
        else: prefix.append((h, p, s + 1))
# print(gestures, prefix)

max_count = 0
for i in range(n):
    count = max(win(0, 1, i), win(0, 2, i), win(1, 0, i), win(1, 2, i), win(2, 0, i), win(2, 1, i))
    max_count = max(max_count, count)

print(max_count)
file = open(&#39;hps.out&#39;, &#39;w&#39;)
file.write(str(max_count))
file.close()
</code></pre>
]]></content>
      <categories>
        <category>CS</category>
        <category>USACO</category>
        <category>Silver</category>
      </categories>
  </entry>
  <entry>
    <title>2017 Bronze December p3</title>
    <url>/y65ng/2020/11/12/2017%20Bronze%20December%20p3/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个 log 由日期（第 i 天），奶牛名字和产奶量变化三部分组成。所有奶牛第 0 天的产奶量都为 7，给出 n 个 log (1 &lt;= n &lt;= 100)，返回这 n 个 log 中产奶量最多的奶牛一共变化的次数</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先将日期和对应的奶牛排序，再遍历排序后的数组，记录每次产奶量最多的奶牛，并与上次做比较，如果不一样则变化量加一</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>排序 n 个元素的复杂度为 O(n logn)，遍历长度为 n 的数组的复杂度为 O(n)，n 最大为 100，不会超时</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>USACO</category>
        <category>Bronze</category>
      </categories>
  </entry>
  <entry>
    <title>2018 Bronze February p2</title>
    <url>/y65ng/2020/11/12/2018%20Bronze%20February%20p2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有 n 头牛站在不同的位置，每头牛只能传球给离自己最近的牛（如果有多头牛距离相同传给左边的），求需要多少球能让所有奶牛都传一次球。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假设让每头奶牛都传一次球，并记录每头奶牛收到球的数量；如果有奶牛收到球的数量为 0，或有两头奶牛相互传球且不会有新的球进来，则需要球的数量加一。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>排序数组的复杂度为n logn，过程中需要遍历两次数组，复杂度都为 O(n)，奶牛数量最大为 100，所以不会超时</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>USACO</category>
        <category>Bronze</category>
      </categories>
  </entry>
  <entry>
    <title>2018 Bronze February p3</title>
    <url>/y65ng/2020/11/12/2018%20Bronze%20February%20p3/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>John 有一个计数器，记录从某次越狱开始每天距离上次奶牛越狱的天数（越狱当天为0）。当他打算统计时，计数器上某些天数被涂掉了（用 -1 表示）。给出总天数 N 和每天记录的天数，返回 N 天中奶牛越狱次数可能的最小值和最大值，若记录的天数有矛盾的地方，返回 -1</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据题目，第一天的数字一定为 0。将记录计数的数组复制一份，原数组用于参考数据，并在新数组上进行更改。从后往前遍历原数组，每当发现一个不为 -1 的元素 m，在新数组中将该元素前 m 个元素更改为相应的降序数字，过程中若发现矛盾，返回 -1。遍历完成后，新数组中 0 的数量即为越狱次数的最小值，0 与 -1 的总数量为最大值</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>由于只需要遍历一次数组，时间复杂度为 O(n)，且 N 最大为 100，不会超时</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>USACO</category>
        <category>Bronze</category>
      </categories>
  </entry>
  <entry>
    <title>Welcome to Yang&#39;s Website</title>
    <url>/y65ng/2020/11/13/Welcome-to-Yang-s-Website/</url>
    <content><![CDATA[<p>不定期更新一些 cs 笔记和打卡</p>
]]></content>
  </entry>
  <entry>
    <title>2016 Silver December p2</title>
    <url>/y65ng/2020/11/12/2016%20Silver%20December%20p2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出 N 个城市（1 ≤ N ≤ 200000），每个城市有自己的名字和长度为两个字母的代号（可能会重复）。若两个城市是一对 special pair ，则这两个城市的名称的前两个字母都是对方的代号。找出这 N 个城市中有多少对 special pair</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将城市的前两个字母和代号分别装进一个长度为 2 的元组的两个房间，并将每个这样的元组装进 hashmap 中，其中每个元组作为 key，出现的次数作为 value。遍历 hashmap，将当前的元组的前后两格互换，若 hashmap 中有与新元组相同的 key，则 count 加上当前的 valve 与新 value 的积</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>遍历 hashmap 的复杂度为 O(N)，在 hashmap 中查找 key 的复杂度为 O(1)，总复杂度为 O(N)。N 最大为 200000，不会超时</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>USACO</category>
        <category>Silver</category>
      </categories>
  </entry>
  <entry>
    <title>Week4 Note</title>
    <url>/y65ng/2020/11/17/week4%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Mining-Bitcoin-with-pencil-and-paper-0-67-hashes-per-day"><a href="#Mining-Bitcoin-with-pencil-and-paper-0-67-hashes-per-day" class="headerlink" title="Mining Bitcoin with pencil and paper: 0.67 hashes per day"></a>Mining Bitcoin with pencil and paper: 0.67 hashes per day</h2><p><a href="http://www.righto.com/2014/09/mining-bitcoin-with-pencil-and-paper.html">http://www.righto.com/2014/09/mining-bitcoin-with-pencil-and-paper.html</a></p>
<p>This article introduces the process how mining works in Bitcoin, which requires miners to find a hash smaller than a specific value. The author also shows the process calculating SHA-256, one of the hash functions, using pen and paper.</p>
<h2 id="ViaBTC-Rises-How-A-mysterious-Miner-Could-Decide-Bitcoin’s-Future"><a href="#ViaBTC-Rises-How-A-mysterious-Miner-Could-Decide-Bitcoin’s-Future" class="headerlink" title="ViaBTC Rises: How A mysterious Miner Could Decide Bitcoin’s Future"></a>ViaBTC Rises: How A mysterious Miner Could Decide Bitcoin’s Future</h2><p><a href="https://www.coindesk.com/viabtc-mystery-miner-bitcoin-scaling-future">https://www.coindesk.com/viabtc-mystery-miner-bitcoin-scaling-future</a></p>
<p>This article introduces a bitcoin mining pool in China called ViaBTC became to support Bitcoin Unlimited instead of Bitcoin Core. There are two ways that are possible to scale the bitcoin block size: Segregated Witness and Bitcoin Unlimited. Segregated Witness is a planned technical fix that would make bitcoin’s block size about 1.8 times larger than original size, while Bitcoin Unlimited allows miners and individual node operator to choose a block size that they prefer instead of limited block size. Either side has its supporters and have continued arguing.</p>
<h2 id="The-Antbleed-Backdoor"><a href="#The-Antbleed-Backdoor" class="headerlink" title="The Antbleed Backdoor"></a>The Antbleed Backdoor</h2><p><a href="https://www.coindesk.com/antbleed-bitcoins-newest-new-controversy-explained">https://www.coindesk.com/antbleed-bitcoins-newest-new-controversy-explained</a></p>
<p>This article introduces a mining chip vulnerability, which some are calling a “backdoor”,  that could potentially be used to remotely shut off bitcoin mining machines. The public fears that someone could exploit the vulnerability to switch off bitcoin mining equipment in bulk and involving mining chip manufacturer Bitmain has been controversial.</p>
<h2 id="Ethereum-Whitepaper"><a href="#Ethereum-Whitepaper" class="headerlink" title="Ethereum Whitepaper"></a>Ethereum Whitepaper</h2><p><a href="https://github.com/ethereum/wiki/wiki/%5B中文%5D-以太坊白皮书">https://github.com/ethereum/wiki/wiki/%5B中文%5D-以太坊白皮书</a></p>
<p>This article first introduces the history of bitcoin and its general principle. Then it states the advantages of implementing some specific functions on ethereum beyond those on bitcoin such as script. It also enumerates other applications of ethereum in practice. </p>
<h2 id="Time-stamped-chatlogs-Why-Jihan-and-Jiang-want-to-block-segwit-at-all-cost"><a href="#Time-stamped-chatlogs-Why-Jihan-and-Jiang-want-to-block-segwit-at-all-cost" class="headerlink" title="Time stamped chatlogs: Why Jihan and Jiang want to block segwit at all cost"></a>Time stamped chatlogs: Why Jihan and Jiang want to block segwit at all cost</h2><p><a href="https://medium.com/bitcoinfoundation/verified-chatlogs-why-jihan-and-jiang-want-to-block-segwit-at-all-cost-bbf068c5ce0f">https://medium.com/bitcoinfoundation/verified-chatlogs-why-jihan-and-jiang-want-to-block-segwit-at-all-cost-bbf068c5ce0f</a></p>
<p>This article shows chatlogs between Chinese miners and a Litecoin developer discussing activating Segwit on Litecoin. Jihan, one of the Chinese miners, supported to activate the Segwit   with a hard fork, while Xinxi, a LTC developer, argued that it should be activated with soft ford instead.</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Bitcoin</category>
      </categories>
  </entry>
</search>
